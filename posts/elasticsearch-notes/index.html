<!doctype html><html lang=en-us><head><title>Elasticsearch Notes | PinYi - Software Engineer</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="因緣際會上了 Elasticsearch 課程，把覺得重要的筆記一下"><meta name=generator content="Hugo 0.81.0"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/hugo.blog/css/style.css><link rel="shortcut icon" href=/hugo.blog/images/favicon.ico type=image/x-icon></head><body><nav class=navigation><a href=/hugo.blog/><span class=arrow>←</span>Home</a>
<a href=/hugo.blog/posts>Archive</a>
<a href=/hugo.blog/tags>Tags</a>
<a href=/hugo.blog/about>About</a></nav><main class=main><section id=single><h1 class=title>Elasticsearch Notes</h1><div class=tip><time datetime="2022-07-12 10:00:00 +0800 +0800">Jul 12, 2022</time>
<span class=split>·</span>
<span>312 words</span>
<span class=split>·</span>
<span>2 minute read</span></div><div class=content><p>因緣際會上了 Elasticsearch 課程，把覺得重要的筆記一下</p><blockquote><p>此篇為各筆記之整理，非原創內容，資料來源可見文後參考資料連結。</p></blockquote><hr><h4 id=query-and-filter>query and filter <a href=#query-and-filter class=anchor>🔗</a></h4><ul><li>query 根據相關性演算法計分，依照相關性高低回傳</li><li>filter 不涉及計分，而且 filter 的結果會被 cache 起來</li></ul><p><a href=https://blog.csdn.net/laoyang360/article/details/80468757 target=_blank rel=noopener>參考連結</a></p><hr><h4 id=inverted-index--segment-file>inverted index 、 segment file <a href=#inverted-index--segment-file class=anchor>🔗</a></h4><ul><li>apache lucene 會將每筆被 index 的資料存成名叫 inverted index 的資料結構</li><li>inverted index 中會存放各個文件中有出現的 terms，並記錄位置、偏移量、詞頻等</li><li>inverted index 大到一定程度時，才寫成為一個 segment file</li><li>segment file 不會再做任何更新或變動，只供讀取</li><li>一個實際的搜尋動作，會使用到許多 segment files</li></ul><hr><h4 id=update-api>update api <a href=#update-api class=anchor>🔗</a></h4><blockquote><p>並不會真的更新文件內容</p></blockquote><ul><li>從該文件的 _source 欄位中取出原內容</li><li>對該 json 進行修改</li><li>將舊文件標示為刪除</li><li>以新的 json 文件內容重新 index</li></ul><hr><h4 id=seq-no--primary-term>seq no & primary term <a href=#seq-no--primary-term class=anchor>🔗</a></h4><blockquote><p>用於確保在分散式架構上 cluster 內資料的一致性</p></blockquote><ul><li>_primary_term：primary shard 改變時+1</li><li>_seq_no：所有 primary shard 上的 operation 都+1</li><li>_version：提供外部使用上能確保資料存取的順序性</li></ul><p><a href=https://www.modb.pro/db/33685 target=_blank rel=noopener>參考連結</a></p><hr><h4 id=searching-request-work>searching request work <a href=#searching-request-work class=anchor>🔗</a></h4><blockquote><p>from 5, size 5<br>搜尋時，各個 shard 都會取 10 個<br>因此拉回 global priority queue 的筆數是 (from + size) * primary shard 數量</p></blockquote><p>可以參考使用 <a href=https://kucw.github.io/blog/2018/6/elasticsearch-scroll/ target=_blank rel=noopener>scroll</a></p><hr><h4 id=score>score <a href=#score class=anchor>🔗</a></h4><blockquote><p>資料少、Shard多時，(5個Shard，3個資料)<br>分數會差異不大，因為每個資料都是單一Shard的唯一資料<br>意思是，分數的比較，是跟單一Shard算出來的</p></blockquote><hr><h4 id=persistence-model>persistence model <a href=#persistence-model class=anchor>🔗</a></h4><blockquote><p>transaction log<br>1.每個操作都會被存成一條 transaction log<br>2.每份被 index 的文件都會被 analyzed 並存在 memory buffer 中<br>3.在 memory buffer 中 的文件不可以被搜尋到<br>4.每 5s 把 transaction log 寫入 disk</p></blockquote><blockquote><p>search refresh<br>1.每秒執行，執行後文件才能被搜尋到<br>2.呼叫 lucene flush，此操作將把 memory buffer 中的文件寫入 directory<br>3.位於 lucene directory 的文件可以被搜尋到，但還沒有 fsync 到磁碟上</p></blockquote><blockquote><p>search flush<br>1.進行 lucene commit & 清理 transaction log<br>2.lucene commit 昂貴，還沒 commit 的資料可能會遺失 (當機)<br>3.因此利用 transaction log 做保障，commit 後，transaction log 也就可以清掉了</p></blockquote><blockquote><p>merge<br>1.當 segment file 數量太多，lucene 會進行 segment merge<br>2.merge 時，同時會移除被 delete 的文件</p></blockquote><p><a href=https://i.imgur.com/Alqjr11.jpg target=_blank rel=noopener>參考連結</a></p><hr><h4 id=object--nested>object & nested <a href=#object--nested class=anchor>🔗</a></h4><p>object 儲存到 es 的時候是被展打儲存的，可以改用 nested</p><pre><code>以下是 object 範例
PUT mytest/doc/1
{
    &quot;group&quot;: &quot;fans&quot;,
    &quot;user&quot;: [
        { &quot;first&quot;: &quot;John&quot;, &quot;last&quot;: &quot;Smith&quot; },
        { &quot;first&quot;: &quot;Alice&quot;, &quot;last&quot;: &quot;White&quot; }
    ]
}

轉換後的內部文檔
{
    &quot;group&quot;: &quot;fans&quot;,
    &quot;user.first&quot;: [ &quot;alice&quot;, &quot;john&quot; ],
    &quot;user.last&quot;: [ &quot;smith&quot;, &quot;white&quot; ]
}
</code></pre><p><a href=https://kucw.github.io/blog/2018/6/elasticsearch-nested/ target=_blank rel=noopener>參考連結</a></p><hr><h4 id=routing-paramter>routing paramter <a href=#routing-paramter class=anchor>🔗</a></h4><blockquote><p>search 預設行為是 query 所有的 node<br>但我們可以讓特定 document index 時，就放在某台 node 上<br>search 時就不需用詢問全部 nodes<br>可在建立 mapping 時，指定存取此 index 時必須在參數指定 routing value</p></blockquote><hr><h4 id=expensive-queries>expensive queries <a href=#expensive-queries class=anchor>🔗</a></h4><ul><li>prex/wildcard query</li><li>fuzzy query</li><li>regexp query</li><li>script query</li><li>join query</li></ul><hr><h4 id=aggregation-request-work>aggregation request work <a href=#aggregation-request-work class=anchor>🔗</a></h4><blockquote><p>size 3<br>因為是各個 shard 先取 3 個，放到 global priority queue 才 aggregation<br>所以 aggregation 數字會失準</p></blockquote><p>可以參考以下兩個回傳值</p><p>doc count error upper bound，表示每個 shard 回傳的最後一筆資料，數字的加總<br>若此數字為0，表示 aggregation 數字是準的</p><p>sum other doc count，表示每個 shard有多少資料沒有回傳</p><hr></div><div class=tags><a href=https://pinyi-lee.github.io/hugo.blog/tags/elasticsearch>elasticsearch</a></div></section></main><footer id=footer><div class=copyright>© Copyright
2022
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg></span></div><div class=powerby>Powered by <a href=http://www.gohugo.io/>Hugo</a> Theme By <a href=https://github.com/nodejh/hugo-theme-mini>nodejh</a></div></footer></body></html>